<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
<!-- End Google Tag Manager -->
  <title>6. Accelerating a perception computational graph &mdash; KRS 1.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Vitis Accelerated Functions with ROS2" href="vitis_accelerated.html" />
    <link rel="prev" title="Accelerating ROS 2 Graphs" href="graphs.html" /> 
</head>

<body class="wy-body-for-nav">

<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
<!-- End Google Tag Manager --> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="../../index.html" class="icon icon-home"> KRS
            <img src="../../_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">SOM</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/">Home</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/creating_applications/2022.1/build/html/index.html">Application Development</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/kria_som_ubuntu_support/build/html/index.html">Ubuntu Support</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/kria-apps-docs/kr260/build/html/index.html">Robotics Starter Kit Applications</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Kria Robotics Stack (KRS)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Install KRS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware.html">Hardware supported</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../features/ros2centric.html">ROS 2-centric</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features/realtime_ros2.html">Real-time ROS 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features/accelerated_apps_ros2.html">ROS 2 Accelerated Apps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../features/contributing_ros2.html">Contributing back to ROS 2</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="nodes.html">Accelerating ROS 2 Nodes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="graphs.html">Accelerating ROS 2 Graphs</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">6. Accelerating a perception computational graph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-perception-computational-graph">The perception computational graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-the-acceleration-kernels">Building the acceleration kernels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#acceleration-of-a-perception-computational-graph-a-step-by-step-guide">Acceleration of a perception computational graph, a step by step guide</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#a-trace-computational-graph">A. Trace computational graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="#b-benchmark-cpu-baseline"><code class="docutils literal notranslate"><span class="pre">B.</span></code> Benchmark CPU baseline</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-hardware-acceleration"><code class="docutils literal notranslate"><span class="pre">C.</span></code> Hardware acceleration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#d-benchmark-acceleration"><code class="docutils literal notranslate"><span class="pre">D.</span></code> Benchmark acceleration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#discussion">Discussion</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="vitis_accelerated.html">Vitis Accelerated Functions with ROS2</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">HowTo</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../howto.html">HowTo and Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../other/definitions.html">Definitions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">KRS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="graphs.html">Accelerating ROS 2 Graphs</a> &raquo;</li>
      <li>6. Accelerating a perception computational graph</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/docs/examples/6_perception.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="accelerating-a-perception-computational-graph">
<h1>6. Accelerating a perception computational graph<a class="headerlink" href="#accelerating-a-perception-computational-graph" title="Permalink to this heading">Â¶</a></h1>
<table border="1" class="docutils">
<thead>
<tr>
<th>Graph</th>
<th>Rationale</th>
<th>Acceleration kernel (FPGA)</th>
<th>Host (CPU)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Perception graph (CPU) (<a href="https://github.com/ros-acceleration/acceleration_examples/blob/main/graphs/perception/perception_2nodes/launch/trace_rectify_resize.launch.py">launch file</a>)</td>
<td>CPU graph, <strong>2 ROS Components</strong></td>
<td></td>
<td><a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/rectify.cpp"><code>rectify.cpp</code></a>, <a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/resize.cpp"><code>resize.cpp</code></a></td>
</tr>
<tr>
<td>Perception graph, offloaded (CPU + FPGA) (<a href="https://github.com/ros-acceleration/acceleration_examples/blob/main/graphs/perception/perception_2nodes/launch/trace_rectify_resize_fpga.launch.py">launch file</a>)</td>
<td>FPGA-offloaded graph, using Vitis Vision Library for OpenCV operations, <strong>2 ROS Components, 2 kernels</strong></td>
<td><a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/image_proc/xf_resize_accel.cpp"><code>resize_accel</code></a>, <a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/image_proc/xf_rectify_accel.cpp"><code>rectify_accel</code></a></td>
<td><a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/rectify_fpga.cpp"><code>rectify_fpga.cpp</code></a>, <a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/resize_fpga.cpp"><code>resize_fpga.cpp</code></a></td>
</tr>
<tr>
<td>Perception graph integrated (CPU + FPGA) (<a href="https://github.com/ros-acceleration/acceleration_examples/blob/main/graphs/perception/perception_2nodes/launch/trace_rectify_resize_fpga_integrated.launch.py">launch file</a>)</td>
<td>FPGA-offloaded graph, re-architected into a single Component, <strong>1 ROS Component, 1 kernel</strong></td>
<td><a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/image_proc/xf_rectify_resize_accel.cpp"><code>rectify_resize_accel</code></a></td>
<td><a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/rectify_resize_fpga_integrated.cpp"><code>rectify_resize_fpga_integrated.cpp</code></a></td>
</tr>
<tr>
<td>Perception graph streamlined (CPU + FPGA) (<a href="https://github.com/ros-acceleration/acceleration_examples/blob/main/graphs/perception/perception_2nodes/launch/trace_rectify_resize_fpga_streamlined.launch.py">launch file</a>)</td>
<td>FPGA-offloaded graph, AXI4 Stream interfaces between ROS 2 Nodes, <strong>2 ROS Components, 2 kernels using stream interfaces</strong>. <em>Note: to connect the pipeline, the second function, resize, subscribes also to the raw image topic, but doesn't use it (fetches data from accelerator).</em>.</td>
<td><a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/image_proc/xf_resize_accel_streamlined.cpp"><code>resize_accel_streamlined</code></a>,  <a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/image_proc/xf_rectify_accel_streamlined.cpp"><code>rectify_accel_streamlined</code></a></td>
<td><a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/resize_fpga_streamlined.cpp"><code>resize_fpga_streamlined.cpp</code></a>, <a href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/rectify_fpga_streamlined.cpp"><code>rectify_fpga_streamlined.cpp</code></a></td>
</tr>
</tbody>
</table><div class="admonition important">
<p class="admonition-title">Important</p>
<p>The source code of the computational graph is available at <a class="reference external" href="https://github.com/ros-acceleration/acceleration_examples/tree/main/graphs/perception/perception_2nodes">perception_2nodes</a> package.</p>
</div>
<section id="the-perception-computational-graph">
<h2>The perception computational graph<a class="headerlink" href="#the-perception-computational-graph" title="Permalink to this heading">Â¶</a></h2>
<p>In this example, we trace, benchmark, and accelerate a subset of  <code class="docutils literal notranslate"><span class="pre">image_pipeline</span></code>, one of the most popular packages in the ROS 2 ecosystem, and a core piece of the ROS perception stack. We compose a simple computational graph consisting of two nodes, <em>resize</em> and <em>rectify</em>, as shown in the figure below. We then leverage KRS for hardware acceleration to benchmark, trace and accelerate our computational graph, comparing a CPU to an FPGA implementation.</p>
<p><img alt="accelerating-ros2-perception" src="https://user-images.githubusercontent.com/1375246/155086310-4b86d491-5513-42e4-8cb8-b1d896dabfe0.png" /></p>
</section>
<section id="building-the-acceleration-kernels">
<h2>Building the acceleration kernels<a class="headerlink" href="#building-the-acceleration-kernels" title="Permalink to this heading">Â¶</a></h2>
<p>Before we provide a completely walkthrough, letâs build the acceleration kernels (you can leave it running in the background since it may take more than an hour):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>~/krs_ws<span class="w">  </span><span class="c1"># head to your KRS workspace</span>

<span class="c1"># prepare the environment</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>/tools/Xilinx/Vitis/2022.1/settings64.sh<span class="w">  </span><span class="c1"># source Xilinx tools</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>/opt/ros/humble/setup.bash<span class="w">  </span><span class="c1"># Sources system ROS 2 installation</span>
$<span class="w"> </span><span class="nb">export</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;/usr/bin&quot;</span>:<span class="nv">$PATH</span><span class="w">  </span><span class="c1"># FIXME: adjust path for CMake 3.5+</span>

<span class="c1"># build the workspace to deploy KRS components</span>
$<span class="w"> </span>colcon<span class="w"> </span>build<span class="w"> </span>--merge-install<span class="w">  </span><span class="c1"># about 2 mins in an AMD Ryzen 5 PRO 4650G</span>

<span class="c1"># source the workspace as an overlay</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>install/setup.bash

<span class="c1"># select kv260 firmware (in case you&#39;ve been experimenting with something else)</span>
$<span class="w"> </span>colcon<span class="w"> </span>acceleration<span class="w"> </span><span class="k">select</span><span class="w"> </span>kv260

<span class="c1"># build all packages up to perception_2nodes, without accelerators</span>
$<span class="w"> </span>colcon<span class="w"> </span>build<span class="w"> </span>--build-base<span class="o">=</span>build-kv260<span class="w"> </span>--install-base<span class="o">=</span>install-kv260<span class="w"> </span>--merge-install<span class="w"> </span>--mixin<span class="w"> </span>kv260<span class="w"> </span>--cmake-args<span class="w"> </span>-DNOKERNELS<span class="o">=</span><span class="nb">true</span><span class="w"> </span>--packages-up-to<span class="w"> </span>perception_2nodes<span class="w"> </span>image_pipeline_examples

<span class="c1"># build image_proc package again, now with accelerators</span>
<span class="c1"># WARNING: this will take a considerable amount of time</span>
$<span class="w"> </span>colcon<span class="w"> </span>build<span class="w"> </span>--build-base<span class="o">=</span>build-kv260<span class="w"> </span>--install-base<span class="o">=</span>install-kv260<span class="w"> </span>--merge-install<span class="w"> </span>--mixin<span class="w"> </span>kv260<span class="w">  </span>--cmake-args<span class="w"> </span>-DNOKERNELS<span class="o">=</span><span class="nb">false</span><span class="w"> </span>--packages-select<span class="w"> </span>image_proc<span class="w"> </span>perception_2nodes

<span class="c1"># copy to KV260 rootfs, e.g.</span>
$<span class="w"> </span>scp<span class="w"> </span>-r<span class="w"> </span>install-kv260/*<span class="w"> </span>petalinux@192.168.1.86:/ros2_ws/
</pre></div>
</div>
</section>
<section id="acceleration-of-a-perception-computational-graph-a-step-by-step-guide">
<h2>Acceleration of a perception computational graph, a step by step guide<a class="headerlink" href="#acceleration-of-a-perception-computational-graph-a-step-by-step-guide" title="Permalink to this heading">Â¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you wish to learn about the ROS 2 methodology for hardware acceleration, refer to <a class="reference external" href="https://github.com/ros-infrastructure/rep/pull/324">REP-2008 Pull Request</a></p>
</div>
<section id="a-trace-computational-graph">
<h3>A. Trace computational graph<a class="headerlink" href="#a-trace-computational-graph" title="Permalink to this heading">Â¶</a></h3>
<p>The first step is to instrument and trace the ROS 2 computational with LTTng probes. Reusing <a class="reference external" href="https://arxiv.org/abs/2201.00393">past work and probes</a> allows us to easily get a grasp of the dataflow interactions within <code class="docutils literal notranslate"><span class="pre">rmw</span></code>, <code class="docutils literal notranslate"><span class="pre">rcl</span></code> and <code class="docutils literal notranslate"><span class="pre">rclcpp</span></code> ROS 2 layers. But to trace appropriately the complete computational graph, besides these tracepoints, we also need to instrument our userland code. Particularly, as depicted for the publication path in the figure below, we need to add instrumentation to the <code class="docutils literal notranslate"><span class="pre">image_pipeline</span></code> package and more specifically, to the ROS <em>Components</em> that weâre using.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>ROS 2  Layer</th>
<th>Trace  point</th>
<th>Desired transition</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>userland</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>image_proc_rectify_init</code></td>
<td>CPU-FPGA</td>
</tr>
<tr>
<td></td>
<td><code>image_proc_rectify_fini</code></td>
<td>FPGA-CPU</td>
</tr>
<tr>
<td></td>
<td><code>image_proc_rectify_cb_fini</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>image_proc_resize_cb_init</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>image_proc_resize_init</code></td>
<td>CPU-FPGA</td>
</tr>
<tr>
<td></td>
<td><code>image_proc_resize_fini</code></td>
<td>FPGA-CPU</td>
</tr>
<tr>
<td></td>
<td><code>image_proc_resize_cb_fini</code></td>
<td></td>
</tr>
<tr>
<td><code>rclcpp</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>callback_start</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>callback_end</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>rclcpp_publish</code></td>
<td></td>
</tr>
<tr>
<td><code>rcl</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>rcl_publish</code></td>
<td></td>
</tr>
<tr>
<td><code>rmw</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>rmw_publish</code></td>
<td></td>
</tr>
</tbody>
</table><p>This is illustrated in the Table above and implemented at https://github.com/ros-perception/image_pipeline/pull/717, including the instrumentation of <code class="docutils literal notranslate"><span class="pre">ResizeNode</span></code> and <code class="docutils literal notranslate"><span class="pre">RectifyNode</span></code> ROS 2 <em>Components</em>. Further instrumentation could be added to these <em>Components</em> if necessary, obtaining more granularity in the tracing efforts.</p>
<p>Below, we depict the results obtained after instrumenting the complete ROS 2 computational graph being studied. A closer inspection shows in grey that the <strong>ROS 2 message-passing system across abstraction layers takes a considerable portion of the CPU</strong>. In comparison, <strong>in light red, taking only a small portion of each Nodeâs execution time</strong>, we depict the computations that interact with the data flowing across nodes. Both the core logic of each one of the Nodes (<em>rectify</em> and <em>resize</em> operations) as well as the ROS 2 message-passing <em>plumbing</em> will be subject to acceleration.</p>
<p><img alt="instrumentation_new" src="https://user-images.githubusercontent.com/1375246/155088908-68ad0195-9f8e-4587-a7af-30d2e006b983.png" /></p>
</section>
<section id="b-benchmark-cpu-baseline">
<h3><code class="docutils literal notranslate"><span class="pre">B.</span></code> Benchmark CPU baseline<a class="headerlink" href="#b-benchmark-cpu-baseline" title="Permalink to this heading">Â¶</a></h3>
<p><img alt="hardware-acceleration-ros2-benchmark-cpu" src="https://user-images.githubusercontent.com/1375246/155089356-94c21e2e-84fe-4dfb-b9bc-39371ed51782.png" /></p>
<p>After tracing the graph and obtaining a good understanding of the dataflow, we can proceed to produce a CPU baseline benchmark while running in the Xilinx KriaÂ® KV260 Vision AI Starter Kit quad-core Processing System (the CPU).</p>
<p>To generate the CPU baseline you can use the pre-cooked ROS 2 launch file which will launch both the tracing capabilities and the corresponding ROS 2 Nodes:</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As documented in <a class="reference external" href="https://github.com/ros-visualization/rqt/issues/187#issuecomment-1001183947">https://github.com/ros-visualization/rqt/issues/187#issuecomment-1001183947</a>, Gazebo plugins and ROS 2 Nodes QoS configurations can often be tricky and not that well aligned historically. At the time of testing, ROS 2 Humble presents such issues. A fix is included among the packages fetched while installing the KRS workspace. If you did not yet, check out the install section and ensure that youâre using a compatible version of âgazebo_ros_pkgsâ package.</p>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Launch Gazebo simulator in your workstation</span>
<span class="c1">#  requires Gazebo installed and GUI-capabilities</span>
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>~/krs_ws<span class="w">  </span><span class="c1"># head to your KRS workspace</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>/opt/ros/humble/setup.bash<span class="w">  </span><span class="c1"># Sources system ROS 2 installation</span>
$<span class="w"> </span>colcon<span class="w"> </span>build<span class="w"> </span>--merge-install<span class="w">  </span><span class="c1"># build the workspace to deploy KRS components</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>install/setup.bash<span class="w">  </span><span class="c1"># source the workspace as an overlay</span>
$<span class="w"> </span>ros2<span class="w"> </span>launch<span class="w"> </span>perception_2nodes<span class="w"> </span>simulation.launch.py

<span class="c1"># Launch the graph in the KV260 CPU (should be connected to the same local network)</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>/opt/ros/humble/setup.bash
$<span class="w"> </span>ros2<span class="w"> </span>launch<span class="w"> </span>perception_2nodes<span class="w"> </span>trace_rectify_resize.launch.py
</pre></div>
</div>
<p><img alt="../../_images/perception_graph.gif" src="../../_images/perception_graph.gif" /></p>
</section>
<section id="c-hardware-acceleration">
<h3><code class="docutils literal notranslate"><span class="pre">C.</span></code> Hardware acceleration<a class="headerlink" href="#c-hardware-acceleration" title="Permalink to this heading">Â¶</a></h3>
<p>The third step in the methodology for ROS 2 hardware acceleration is to introduce custom compute architectures by using specialized hardware (FPGAs or GPUs). This is done in two steps: first, creating acceleration kernels for individual ROS 2 <em>Nodes</em> and <em>Component</em> and second, accelerate the computational graph by tracing and optimize dataflow interactions. The whole process can take various iterations until results are satisfactory.</p>
<section id="accelerate-ros-2-nodes-and-components">
<h4>Accelerate ROS 2 Nodes and Components<a class="headerlink" href="#accelerate-ros-2-nodes-and-components" title="Permalink to this heading">Â¶</a></h4>
<p>We first accelerate the computations at each one of the graph nodes. <code class="docutils literal notranslate"><span class="pre">/rectify_node_fpga</span></code> and <code class="docutils literal notranslate"><span class="pre">/resize/resize_node_fpga</span></code> <em>Components</em> of the use case above are accelerated using Xilinxâs HLS, XRT and OpenCL targeting the Kria KV260. The changes in the ROS 2 <em>Components</em> of <code class="docutils literal notranslate"><span class="pre">image_pipeline</span></code> to leverage hardware acceleration in the FPGA are available in <a class="reference external" href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/rectify_fpga.cpp"><code class="docutils literal notranslate"><span class="pre">rectify_fpga</span></code></a> and <a class="reference external" href="https://github.com/ros-acceleration/image_pipeline/blob/ros2/image_proc/src/resize_fpga.cpp"><code class="docutils literal notranslate"><span class="pre">resize_fpga</span></code></a> respectively. Each one of the ROS 2 <em>Components</em> has an associated acceleration kernel that leverages the Vitis Vision Library, a computer vision library optimized for Xilinx silicon solutions and based on OpenCV APIs. Source code of the acceleration kernels is available <a class="reference external" href="https://github.com/ros-acceleration/image_pipeline/tree/ros2/image_proc/src/image_proc">here</a>.  Itâs relevant to note how the code implementation of these accelerated <em>Components</em> and its kernels co-exists well with the rest of the ROS meta-package. Thanks to the work of the WG, building accelerators is abstracted away from the roboticists and takes no significant additional effort than the usual build of <code class="docutils literal notranslate"><span class="pre">image_pipeline</span></code>.</p>
<p><img alt="hardware-acceleration-ros2-benchmark-cpu" src="https://user-images.githubusercontent.com/1375246/155089356-94c21e2e-84fe-4dfb-b9bc-39371ed51782.png" /></p>
<p>Figure above depicts the results obtained after benchmarking these accelerated <em>Components</em> using the trace points. We observe an average 6.22% speedup in the total computation time of the perception pipeline after offloading perception tasks to the FPGA.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th></th>
<th>Accel. Mean</th>
<th>Accel. RMS</th>
<th>Mean</th>
<th>RMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU <strong>baseline</strong></td>
<td><strong>24.36</strong> ms (<code>0.00</code>%)</td>
<td><strong>24.50</strong> ms (<code>0.00</code>%)</td>
<td><strong>91.48</strong> ms (<code>0.00</code>%)</td>
<td><strong>92.05</strong> ms (<code>0.00</code>%)</td>
</tr>
<tr>
<td>FPGA @ 250 MHz</td>
<td>24.46 ms (:small_red_triangle_down: <code>0.41</code>%)</td>
<td>24.66 ms (:small_red_triangle_down: <code>0.63</code>%)</td>
<td>85.80 ms (<code>6.22</code>%)</td>
<td>87.87 ms (<code>4.54</code>%)</td>
</tr>
</tbody>
</table><p>To launch the perception graph with FPGA offloading using the Vitis Vision Library:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Launch the graph in the KV260 CPU (should be connected to the same local network as the workstation)</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>/opt/ros/humble/setup.bash<span class="w">  </span><span class="c1"># enable ROS 2 overlays</span>
$<span class="w"> </span>ros2<span class="w"> </span>acceleration<span class="w"> </span><span class="k">select</span><span class="w"> </span>image_proc<span class="w">  </span><span class="c1"># select and load the accelerator</span>
$<span class="w"> </span>ros2<span class="w"> </span>launch<span class="w"> </span>perception_2nodes<span class="w"> </span>trace_rectify_resize_fpga.launch.py<span class="w">  </span><span class="c1"># launch Nodes</span>
</pre></div>
</div>
<p><img alt="../../_images/perception_graph_fpga.gif" src="../../_images/perception_graph_fpga.gif" /></p>
</section>
<section id="accelerate-graph">
<h4>Accelerate Graph<a class="headerlink" href="#accelerate-graph" title="Permalink to this heading">Â¶</a></h4>
<p>As illustrated before through tracing, inter-Node exchanges using the ROS 2 message-passing system across its abstraction layers outweights other operations by far, regardless of the compute substrate. This confirms the CPU-centric approach in ROS, and hints about one important opportunity where hardware acceleration can hasten ROS 2 computational graphs. By optimizing inter-Node dataflows, ROS 2 intra-process and inter-process communications can be made more time efficient, leading to faster resolution of the graph computations and ultimately, to faster robots. This step is thereby focused on optimizing the dataflow within the computational graph and across ROS 2 Nodes and Components. Figures  below depict two attempts to accelerate the graph dataflow.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>integrated approach</th>
<th>streamlining approach</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="benchmarkintegrated_only" src="https://user-images.githubusercontent.com/1375246/155095594-ae46f814-3d0b-4050-979b-08d6e2cbe83e.png" /></td>
<td><img alt="benchmarkresize_only" src="https://user-images.githubusercontent.com/1375246/155095607-1a0eb07b-536b-4144-8458-fdccb8d06845.png" /></td>
</tr>
</tbody>
</table><p>The first one integrates both ROS <em>Components</em> into a new one. The benefit of doing so is two-fold: first, we avoid the ROS 2 message-passing system between <code class="docutils literal notranslate"><span class="pre">RectifyNode</span></code> and <code class="docutils literal notranslate"><span class="pre">ResizeNode</span></code> <em>Components</em>. Second, we avoid the compute cycles wasted while memory mapping back and forth data between the host CPU and the FPGA, achieving an overall faster acceleration which totals in an average <strong>26.96% speedup</strong> while benchmarking the graph for 60 seconds.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th></th>
<th>Accel. Mean</th>
<th>Accel. RMS</th>
<th>Mean</th>
<th>RMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU <strong>baseline</strong></td>
<td><strong>24.36</strong> ms (<code>0.00</code>%)</td>
<td><strong>24.50</strong> ms (<code>0.00</code>%)</td>
<td><strong>91.48</strong> ms (<code>0.00</code>%)</td>
<td><strong>92.05</strong> ms (<code>0.00</code>%)</td>
</tr>
<tr>
<td>FPGA, integrated @ 250 MHz</td>
<td>23.90 ms (<code>1.88</code>%)</td>
<td>24.05 ms (<code>1.84</code>%)</td>
<td>66.82 ms (<code>26.96</code>%)</td>
<td>67.82 ms (<code>26.32</code>%)</td>
</tr>
</tbody>
</table><p>The second attempt results from using the accelerated <em>Components</em> <code class="docutils literal notranslate"><span class="pre">RectifyNodeFPGAStreamlined</span></code> and <code class="docutils literal notranslate"><span class="pre">ResizeNodeFPGAStreamlined</span></code>. These ROS <em>Components</em> are redesigned to leverage hardware acceleration, however, besides offloading perception tasks to the FPGA, each <ins>leverages an AXI4-Stream interface to <strong>create an intra-FPGA ROS 2 communication queue</strong> which is then used to pass data across nodes through the FPGA</ins>. This allows to avoid completely the ROS 2 message-passing system and optimizes dataflow achieving a <strong>24.42% total speedup</strong> resulting from averaging the measurements collected while benchmarking the graph for 60 seconds.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th></th>
<th>Accel. Mean</th>
<th>Accel. RMS</th>
<th>Mean</th>
<th>RMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU <strong>baseline</strong></td>
<td><strong>24.36</strong> ms (<code>0.00</code>%)</td>
<td><strong>24.50</strong> ms (<code>0.00</code>%)</td>
<td><strong>91.48</strong> ms (<code>0.00</code>%)</td>
<td><strong>92.05</strong> ms (<code>0.00</code>%)</td>
</tr>
<tr>
<td>FPGA, streams (resize) @ 250 MHz</td>
<td>19.14 ms (<code>21.42</code>%)</td>
<td>19.28 ms (<code>21.33</code>%)</td>
<td>69.15 ms (<code>24.42</code>%)</td>
<td>70.18 ms (<code>23.75</code>%)</td>
</tr>
</tbody>
</table><p>To launch the <em>integrated</em> and <em>streamlined</em> approaches:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># integrated</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>/opt/ros/humble/setup.bash<span class="w">  </span><span class="c1"># enable ROS 2 overlays</span>
$<span class="w"> </span>ros2<span class="w"> </span>acceleration<span class="w"> </span><span class="k">select</span><span class="w"> </span>image_proc_integrated<span class="w">  </span><span class="c1"># select and load the accelerator</span>
$<span class="w"> </span>ros2<span class="w"> </span>launch<span class="w"> </span>perception_2nodes<span class="w"> </span>trace_rectify_resize_fpga_integrated.launch.py<span class="w">  </span><span class="c1"># launch Nodes</span>
</pre></div>
</div>
<p><img alt="../../_images/perception_graph_integrated.gif" src="../../_images/perception_graph_integrated.gif" /></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># streamlined</span>
$<span class="w"> </span><span class="nb">source</span><span class="w"> </span>/opt/ros/humble/setup.bash<span class="w">  </span><span class="c1"># enable ROS 2 overlays</span>
$<span class="w"> </span>ros2<span class="w"> </span>acceleration<span class="w"> </span><span class="k">select</span><span class="w"> </span>image_proc_streamlined<span class="w">  </span><span class="c1"># select and load the accelerator</span>
$<span class="w"> </span>ros2<span class="w"> </span>launch<span class="w"> </span>perception_2nodes<span class="w"> </span>trace_rectify_resize_fpga_streamlined.launch.py<span class="w">  </span><span class="c1"># launch Nodes</span>
</pre></div>
</div>
<p><img alt="../../_images/perception_graph_streamlined.gif" src="../../_images/perception_graph_streamlined.gif" /></p>
</section>
</section>
<section id="d-benchmark-acceleration">
<h3><code class="docutils literal notranslate"><span class="pre">D.</span></code> Benchmark acceleration<a class="headerlink" href="#d-benchmark-acceleration" title="Permalink to this heading">Â¶</a></h3>
<p><img alt="benchmarkstreams" src="https://user-images.githubusercontent.com/1375246/155090477-2d468361-337a-43c7-b1a3-0e1b2a588dba.png" /></p>
<p>The last step in the methodology for ROS 2 hardware acceleration is to continuously benchmark the acceleration results after creating custom compute architectures and against the CPU baseline. Figures above presents results obtained iteratively while building custom hardware interfaces for the Xilinx Kria KV260 FPGA SoC.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th></th>
<th>Accel. Mean</th>
<th>Accel. RMS</th>
<th>Mean</th>
<th>RMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU <strong>baseline</strong></td>
<td><strong>24.36</strong> ms (<code>0.00</code>%)</td>
<td><strong>24.50</strong> ms (<code>0.00</code>%)</td>
<td><strong>91.48</strong> ms (<code>0.00</code>%)</td>
<td><strong>92.05</strong> ms (<code>0.00</code>%)</td>
</tr>
<tr>
<td>FPGA @ 250 MHz</td>
<td>24.46 ms (:small_red_triangle_down: <code>0.41</code>%)</td>
<td>24.66 ms (:small_red_triangle_down: <code>0.63</code>%)</td>
<td>85.80 ms (<code>6.22</code>%)</td>
<td>87.87 ms (<code>4.54</code>%)</td>
</tr>
<tr>
<td>FPGA, integrated @ 250 MHz</td>
<td>23.90 ms (<code>1.88</code>%)</td>
<td>24.05 ms (<code>1.84</code>%)</td>
<td>66.82 ms (<code>26.96</code>%)</td>
<td>67.82 ms (<code>26.32</code>%)</td>
</tr>
<tr>
<td>FPGA, streams (resize) @ 250 MHz</td>
<td>19.14 ms (<code>21.42</code>%)</td>
<td>19.28 ms (<code>21.33</code>%)</td>
<td>69.15 ms (<code>24.42</code>%)</td>
<td>70.18 ms (<code>23.75</code>%)</td>
</tr>
</tbody>
</table></section>
</section>
<section id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this heading">Â¶</a></h2>
<p>The previous analysis shows for a simple perception robotics task how by leveraging the ROS 2 Hardware Acceleration open architecture and following the proposed methodology, we are able to use hardware acceleration easily, without changing the development flow, and while obtaining faster ROS 2 responses. We demonstrated how:</p>
<ol class="simple">
<li><p>pure perception FPGA offloading leads to a 6.22% speedup for our application,</p></li>
<li><p>we also showed how re-architecting and integrating the ROS <em>Components</em> into a single FPGA-accelerated and optimized <em>Component</em> led to a 26.96% speedup. This <ins>comes at the cost of having to re-architect the ROS computational graph, merging Components as most appropriate, while breaking the ROS modularity and granularity assumptions conveyed in the default perception stack</ins>. To avoid doing so and lower the entry barrier for roboticists, finally,</p></li>
<li><p>we <strong>design two new <em>Components</em> which offload perception tasks to the FPGA and leverage an AXI4-Stream interface to create an intra-FPGA ROS 2 Node communication queue</strong>. Using this queue, our new ROS <em>Components</em> deliver <em>faster dataflows and achieve an inter-Node performance speedup of 24.42%</em>. We believe that <ins>using this intra-FPGA ROS 2 Node communication queue, the acceleration speedup can also be exploited in subsequent Nodes of the computational graph dataflow, leading to an exponential acceleration gain</ins>. Best of all, our intra-FPGA ROS 2 Node communication queue aligns well with modern ROS 2 composition capabilities and allows ROS 2 <em>Components</em> and <em>Nodes</em> to exploit this communication pattern for inter- and intra-process ROS 2 communications.</p></li>
</ol>
</section>
</section>


           </div>
          </div>
          
				  
				  <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="graphs.html" class="btn btn-neutral float-left" title="Accelerating ROS 2 Graphs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vitis_accelerated.html" class="btn btn-neutral float-right" title="Vitis Accelerated Functions with ROS2" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2024, dvanced Micro Devices, Inc.
      <span class="lastupdated">Last updated on January 2, 2024.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>